========
Versions
========

150529: Initial tests
------
- Function based, testing algos and overall tracking
- Spot recognition:
    - LoG based
- Spot tracking:
    - Minimal distance based algo. 
    - Mostly numpy ufuncs and filters with masked arrays
    - No support for blinking. Max_dist = 1
- Barriers recognition:
    - Hough lines, basic proof of concept

150717: OK results, fast.
-------
- Spot recognition:
    - Added basic support for limits while importing
- Spot Tracking:
    - Added support for blinking
    - Can write and open track files
    - Added function to draw tracks. It is not possible to save all images in memory at once when writing spots, for memory is too short. Must go image by image.
- Imported sy_plot function from SpotTracker

150720: Correction of the algorithm, good results, fast
-------
- Imported histogram function from SpotTracker. Added support for properties other than x-pos
- Spot tracking:
    - The basic algorithm of previous versions in wrong. np.min in axis 0 or 1 does not consider axis 2 as pairs. It will return the minimum for 0 and then for 1 in axis 2, instead of what I expected, the minimum for (0, 1) in axis 2.
    - Corrected the algorithm by loosing the 3rd dimension. First, mask is established for spots where displacement in x or y is > max_disp. Then, x and y are merged (x**2+y**2)**1/2. Minimums are calculated in the 2D array, avoiding ambiguity.
    - Algorithm still fit several spots per frame
    - Moving filtering to another function

150721: Dealing with ambiguous tracks
-------
- Spot tracking:
    - Ambiguous tracks contain more than 1 spot per frame. This are spots that share the same path. They're hard to pull apart. Added an option to discard these tracks. Going subpixel resolution may help to remove these ambiguities.
    - 
- Spot recognition:
    - Subpixel resolution is quite bad for dyes, probably because the Gaussian spans across 2-3 pixels and the highest intensity is barely above noise... Did not try with QDots.
    - Implemented function to find exclusively spots that are between the barriers
- Inverted the x and y values when loading spots, for conventions must prevail.
- Implemented functions for transitive reduction and transitive closure of graphs
- Implemented algorithm for finding barriers
- Implemented algorithm for correcting the rotation of the images based on the barriers

150811: Implementation of Images, Dataset and Experiment classes
-------
In everyday language, an experiment represents either the battery of tests made to test an hypothesis, or every single one of these tests that ultimately lead to a body of evidence.
Hence, an experiment can either consist in a dataset with all exact same conditions, or a set of datasets of more or less different conditions.

- Parameters: dictionary object that allow to use getters and setters on values and can still be used as **kwargs
    - Any of the following allows to set a Parameter:
        - Parameters['param'] = value
        - Parameters.param = value
        - Parameters.update(param = value)
        - Parameters.update(('param', value))
        - Parameters.update({'param': value})
    - update() allows to update a Parameter object with another Parameter object or with a list/dictionary
    - If an attribute is not found in the object itself, it will look in the Parameters.defaults dict, which is static.
    - 

- Datasets: series of interactions between molecules that are aligned in dimensions and are all from the same experiment/conditions. 
    - Allows to set experimental parameters and other comments just like a Parameters object.
    - 

- Experiments: containers that allow to group and manipulate datasets
    - 

- Images: wrapper to read images for BioFormats or tiff series
    - read: returns all images, one by one (generator)
